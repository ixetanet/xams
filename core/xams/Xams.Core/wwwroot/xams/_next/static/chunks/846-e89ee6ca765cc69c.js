"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[846],{4238:(e,t,n)=>{n.d(t,{MU:()=>r,Y3:()=>c,YW:()=>l,az:()=>a,j$:()=>o,lc:()=>s,tJ:()=>h,zN:()=>i});class o extends Error{constructor(e,t){let n=new.target.prototype;super(`${e}: Status code '${t}'`),this.statusCode=t,this.__proto__=n}}class r extends Error{constructor(e="A timeout occurred."){let t=new.target.prototype;super(e),this.__proto__=t}}class s extends Error{constructor(e="An abort occurred."){let t=new.target.prototype;super(e),this.__proto__=t}}class i extends Error{constructor(e,t){let n=new.target.prototype;super(e),this.transport=t,this.errorType="UnsupportedTransportError",this.__proto__=n}}class c extends Error{constructor(e,t){let n=new.target.prototype;super(e),this.transport=t,this.errorType="DisabledTransportError",this.__proto__=n}}class a extends Error{constructor(e,t){let n=new.target.prototype;super(e),this.transport=t,this.errorType="FailedToStartTransportError",this.__proto__=n}}class l extends Error{constructor(e){let t=new.target.prototype;super(e),this.errorType="FailedToNegotiateWithServerError",this.__proto__=t}}class h extends Error{constructor(e,t){let n=new.target.prototype;super(e),this.innerErrors=t,this.__proto__=n}}},5764:(e,t,n)=>{n.d(t,{x:()=>o});let o="9.0.6"},6622:(e,t,n)=>{n.d(t,{Q:()=>o});class o{constructor(){}log(e,t){}}o.instance=new o},6736:(e,t,n)=>{var o;n.d(t,{$:()=>o}),function(e){e[e.Trace=0]="Trace",e[e.Debug=1]="Debug",e[e.Information=2]="Information",e[e.Warning=3]="Warning",e[e.Error=4]="Error",e[e.Critical=5]="Critical",e[e.None=6]="None"}(o||(o={}))},6962:(e,t,n)=>{n.d(t,{AL:()=>p,Cr:()=>d,Gp:()=>l,OD:()=>a,WH:()=>f,We:()=>m,YU:()=>u,_z:()=>g,h:()=>_,mw:()=>h,z6:()=>c});var o=n(6736),r=n(6622),s=n(5764),i=n(8304);class c{static isRequired(e,t){if(null==e)throw Error(`The '${t}' argument is required.`)}static isNotEmpty(e,t){if(!e||e.match(/^\s*$/))throw Error(`The '${t}' argument should not be empty.`)}static isIn(e,t,n){if(!(e in t))throw Error(`Unknown ${n} value: ${e}.`)}}class a{static get isBrowser(){return!a.isNode&&"object"==typeof window&&"object"==typeof window.document}static get isWebWorker(){return!a.isNode&&"object"==typeof self&&"importScripts"in self}static get isReactNative(){return!a.isNode&&"object"==typeof window&&void 0===window.document}static get isNode(){return void 0!==i&&i.release&&"node"===i.release.name}}function l(e,t){let n="";return h(e)?(n=`Binary data of length ${e.byteLength}`,t&&(n+=`. Content: '${function(e){let t=new Uint8Array(e),n="";return t.forEach(e=>{let t=e<16?"0":"";n+=`0x${t}${e.toString(16)} `}),n.substr(0,n.length-1)}(e)}'`)):"string"==typeof e&&(n=`String data of length ${e.length}`,t&&(n+=`. Content: '${e}'`)),n}function h(e){return e&&"undefined"!=typeof ArrayBuffer&&(e instanceof ArrayBuffer||e.constructor&&"ArrayBuffer"===e.constructor.name)}async function g(e,t,n,r,s,i){let c={},[a,g]=p();c[a]=g,e.log(o.$.Trace,`(${t} transport) sending data. ${l(s,i.logMessageContent)}.`);let _=h(s)?"arraybuffer":"text",u=await n.post(r,{content:s,headers:{...c,...i.headers},responseType:_,timeout:i.timeout,withCredentials:i.withCredentials});e.log(o.$.Trace,`(${t} transport) request complete. Response status: ${u.statusCode}.`)}function _(e){return void 0===e?new d(o.$.Information):null===e?r.Q.instance:void 0!==e.log?e:new d(e)}class u{constructor(e,t){this._subject=e,this._observer=t}dispose(){let e=this._subject.observers.indexOf(this._observer);e>-1&&this._subject.observers.splice(e,1),0===this._subject.observers.length&&this._subject.cancelCallback&&this._subject.cancelCallback().catch(e=>{})}}class d{constructor(e){this._minLevel=e,this.out=console}log(e,t){if(e>=this._minLevel){let n=`[${new Date().toISOString()}] ${o.$[e]}: ${t}`;switch(e){case o.$.Critical:case o.$.Error:this.out.error(n);break;case o.$.Warning:this.out.warn(n);break;case o.$.Information:this.out.info(n);break;default:this.out.log(n)}}}}function p(){let e="X-SignalR-User-Agent";return a.isNode&&(e="User-Agent"),[e,function(e,t,n,o){let r="Microsoft SignalR/",s=e.split(".");return r+=`${s[0]}.${s[1]} (${e}; `,t&&""!==t?r+=`${t}; `:r+="Unknown OS; ",r+=`${n}`,o?r+=`; ${o}`:r+="; Unknown Runtime Version",r+=")"}(s.x,function(){if(!a.isNode)return"";switch(i.platform){case"win32":return"Windows NT";case"darwin":return"macOS";case"linux":return"Linux";default:return i.platform}}(),a.isNode?"NodeJS":"Browser",function(){if(a.isNode)return i.versions.node}())]}function f(e){return e.stack?e.stack:e.message?e.message:`${e}`}function m(){if("undefined"!=typeof globalThis)return globalThis;if("undefined"!=typeof self)return self;if("undefined"!=typeof window)return window;if(void 0!==n.g)return n.g;throw Error("could not find global")}},8098:(e,t,n)=>{n.d(t,{s:()=>o});class o{static write(e){return`${e}${o.RecordSeparator}`}static parse(e){if(e[e.length-1]!==o.RecordSeparator)throw Error("Message is incomplete.");let t=e.split(o.RecordSeparator);return t.pop(),t}}o.RecordSeparatorCode=30,o.RecordSeparator=String.fromCharCode(o.RecordSeparatorCode)},8846:(e,t,n)=>{n.d(t,{q:()=>u,j:()=>o});var o,r=n(8098),s=n(6962);class i{writeHandshakeRequest(e){return r.s.write(JSON.stringify(e))}parseHandshakeResponse(e){let t,n;if((0,s.mw)(e)){let o=new Uint8Array(e),s=o.indexOf(r.s.RecordSeparatorCode);if(-1===s)throw Error("Message is incomplete.");let i=s+1;t=String.fromCharCode.apply(null,Array.prototype.slice.call(o.slice(0,i))),n=o.byteLength>i?o.slice(i).buffer:null}else{let o=e.indexOf(r.s.RecordSeparator);if(-1===o)throw Error("Message is incomplete.");let s=o+1;t=e.substring(0,s),n=e.length>s?e.substring(s):null}let o=JSON.parse(r.s.parse(t)[0]);if(o.type)throw Error("Expected a handshake response from the server.");return[n,o]}}var c=n(4238),a=n(9091),l=n(6736),h=n(9679);class g{constructor(e,t,n){this._bufferSize=1e5,this._messages=[],this._totalMessageCount=0,this._waitForSequenceMessage=!1,this._nextReceivingSequenceId=1,this._latestReceivedSequenceId=0,this._bufferedByteCount=0,this._reconnectInProgress=!1,this._protocol=e,this._connection=t,this._bufferSize=n}async _send(e){let t=this._protocol.writeMessage(e),n=Promise.resolve();if(this._isInvocationMessage(e)){this._totalMessageCount++;let e=()=>{},o=()=>{};(0,s.mw)(t)?this._bufferedByteCount+=t.byteLength:this._bufferedByteCount+=t.length,this._bufferedByteCount>=this._bufferSize&&(n=new Promise((t,n)=>{e=t,o=n})),this._messages.push(new _(t,this._totalMessageCount,e,o))}try{this._reconnectInProgress||await this._connection.send(t)}catch{this._disconnected()}await n}_ack(e){let t=-1;for(let n=0;n<this._messages.length;n++){let o=this._messages[n];if(o._id<=e.sequenceId)t=n,(0,s.mw)(o._message)?this._bufferedByteCount-=o._message.byteLength:this._bufferedByteCount-=o._message.length,o._resolver();else if(this._bufferedByteCount<this._bufferSize)o._resolver();else break}-1!==t&&(this._messages=this._messages.slice(t+1))}_shouldProcessMessage(e){if(this._waitForSequenceMessage)if(e.type!==a.G.Sequence)return!1;else return this._waitForSequenceMessage=!1,!0;if(!this._isInvocationMessage(e))return!0;let t=this._nextReceivingSequenceId;return(this._nextReceivingSequenceId++,t<=this._latestReceivedSequenceId)?(t===this._latestReceivedSequenceId&&this._ackTimer(),!1):(this._latestReceivedSequenceId=t,this._ackTimer(),!0)}_resetSequence(e){if(e.sequenceId>this._nextReceivingSequenceId)return void this._connection.stop(Error("Sequence ID greater than amount of messages we've received."));this._nextReceivingSequenceId=e.sequenceId}_disconnected(){this._reconnectInProgress=!0,this._waitForSequenceMessage=!0}async _resend(){let e=0!==this._messages.length?this._messages[0]._id:this._totalMessageCount+1;for(let t of(await this._connection.send(this._protocol.writeMessage({type:a.G.Sequence,sequenceId:e})),this._messages))await this._connection.send(t._message);this._reconnectInProgress=!1}_dispose(e){for(let t of(null!=e||(e=Error("Unable to reconnect to server.")),this._messages))t._rejector(e)}_isInvocationMessage(e){switch(e.type){case a.G.Invocation:case a.G.StreamItem:case a.G.Completion:case a.G.StreamInvocation:case a.G.CancelInvocation:return!0;case a.G.Close:case a.G.Sequence:case a.G.Ping:case a.G.Ack:return!1}}_ackTimer(){void 0===this._ackTimerHandle&&(this._ackTimerHandle=setTimeout(async()=>{try{this._reconnectInProgress||await this._connection.send(this._protocol.writeMessage({type:a.G.Ack,sequenceId:this._latestReceivedSequenceId}))}catch{}clearTimeout(this._ackTimerHandle),this._ackTimerHandle=void 0},1e3))}}class _{constructor(e,t,n,o){this._message=e,this._id=t,this._resolver=n,this._rejector=o}}!function(e){e.Disconnected="Disconnected",e.Connecting="Connecting",e.Connected="Connected",e.Disconnecting="Disconnecting",e.Reconnecting="Reconnecting"}(o||(o={}));class u{static create(e,t,n,o,r,s,i){return new u(e,t,n,o,r,s,i)}constructor(e,t,n,r,c,h,g){this._nextKeepAlive=0,this._freezeEventListener=()=>{this._logger.log(l.$.Warning,"The page is being frozen, this will likely lead to the connection being closed and messages being lost. For more information see the docs at https://learn.microsoft.com/aspnet/core/signalr/javascript-client#bsleep")},s.z6.isRequired(e,"connection"),s.z6.isRequired(t,"logger"),s.z6.isRequired(n,"protocol"),this.serverTimeoutInMilliseconds=null!=c?c:3e4,this.keepAliveIntervalInMilliseconds=null!=h?h:15e3,this._statefulReconnectBufferSize=null!=g?g:1e5,this._logger=t,this._protocol=n,this.connection=e,this._reconnectPolicy=r,this._handshakeProtocol=new i,this.connection.onreceive=e=>this._processIncomingData(e),this.connection.onclose=e=>this._connectionClosed(e),this._callbacks={},this._methods={},this._closedCallbacks=[],this._reconnectingCallbacks=[],this._reconnectedCallbacks=[],this._invocationId=0,this._receivedHandshakeResponse=!1,this._connectionState=o.Disconnected,this._connectionStarted=!1,this._cachedPingMessage=this._protocol.writeMessage({type:a.G.Ping})}get state(){return this._connectionState}get connectionId(){return this.connection&&this.connection.connectionId||null}get baseUrl(){return this.connection.baseUrl||""}set baseUrl(e){if(this._connectionState!==o.Disconnected&&this._connectionState!==o.Reconnecting)throw Error("The HubConnection must be in the Disconnected or Reconnecting state to change the url.");if(!e)throw Error("The HubConnection url must be a valid url.");this.connection.baseUrl=e}start(){return this._startPromise=this._startWithStateTransitions(),this._startPromise}async _startWithStateTransitions(){if(this._connectionState!==o.Disconnected)return Promise.reject(Error("Cannot start a HubConnection that is not in the 'Disconnected' state."));this._connectionState=o.Connecting,this._logger.log(l.$.Debug,"Starting HubConnection.");try{await this._startInternal(),s.OD.isBrowser&&window.document.addEventListener("freeze",this._freezeEventListener),this._connectionState=o.Connected,this._connectionStarted=!0,this._logger.log(l.$.Debug,"HubConnection connected successfully.")}catch(e){return this._connectionState=o.Disconnected,this._logger.log(l.$.Debug,`HubConnection failed to start successfully because of error '${e}'.`),Promise.reject(e)}}async _startInternal(){this._stopDuringStartError=void 0,this._receivedHandshakeResponse=!1;let e=new Promise((e,t)=>{this._handshakeResolver=e,this._handshakeRejecter=t});await this.connection.start(this._protocol.transferFormat);try{let t=this._protocol.version;this.connection.features.reconnect||(t=1);let n={protocol:this._protocol.name,version:t};if(this._logger.log(l.$.Debug,"Sending handshake request."),await this._sendMessage(this._handshakeProtocol.writeHandshakeRequest(n)),this._logger.log(l.$.Information,`Using HubProtocol '${this._protocol.name}'.`),this._cleanupTimeout(),this._resetTimeoutPeriod(),this._resetKeepAliveInterval(),await e,this._stopDuringStartError)throw this._stopDuringStartError;(this.connection.features.reconnect||0)&&(this._messageBuffer=new g(this._protocol,this.connection,this._statefulReconnectBufferSize),this.connection.features.disconnected=this._messageBuffer._disconnected.bind(this._messageBuffer),this.connection.features.resend=()=>{if(this._messageBuffer)return this._messageBuffer._resend()}),this.connection.features.inherentKeepAlive||await this._sendMessage(this._cachedPingMessage)}catch(e){throw this._logger.log(l.$.Debug,`Hub handshake failed with error '${e}' during start(). Stopping HubConnection.`),this._cleanupTimeout(),this._cleanupPingTimer(),await this.connection.stop(e),e}}async stop(){let e=this._startPromise;this.connection.features.reconnect=!1,this._stopPromise=this._stopInternal(),await this._stopPromise;try{await e}catch(e){}}_stopInternal(e){if(this._connectionState===o.Disconnected)return this._logger.log(l.$.Debug,`Call to HubConnection.stop(${e}) ignored because it is already in the disconnected state.`),Promise.resolve();if(this._connectionState===o.Disconnecting)return this._logger.log(l.$.Debug,`Call to HttpConnection.stop(${e}) ignored because the connection is already in the disconnecting state.`),this._stopPromise;let t=this._connectionState;return(this._connectionState=o.Disconnecting,this._logger.log(l.$.Debug,"Stopping HubConnection."),this._reconnectDelayHandle)?(this._logger.log(l.$.Debug,"Connection stopped during reconnect delay. Done reconnecting."),clearTimeout(this._reconnectDelayHandle),this._reconnectDelayHandle=void 0,this._completeClose(),Promise.resolve()):(t===o.Connected&&this._sendCloseMessage(),this._cleanupTimeout(),this._cleanupPingTimer(),this._stopDuringStartError=e||new c.lc("The connection was stopped before the hub handshake could complete."),this.connection.stop(e))}async _sendCloseMessage(){try{await this._sendWithProtocol(this._createCloseMessage())}catch{}}stream(e,...t){let n,[o,r]=this._replaceStreamingParams(t),s=this._createStreamInvocation(e,t,r),i=new h.B;return i.cancelCallback=()=>{let e=this._createCancelInvocation(s.invocationId);return delete this._callbacks[s.invocationId],n.then(()=>this._sendWithProtocol(e))},this._callbacks[s.invocationId]=(e,t)=>{if(t)return void i.error(t);e&&(e.type===a.G.Completion?e.error?i.error(Error(e.error)):i.complete():i.next(e.item))},n=this._sendWithProtocol(s).catch(e=>{i.error(e),delete this._callbacks[s.invocationId]}),this._launchStreams(o,n),i}_sendMessage(e){return this._resetKeepAliveInterval(),this.connection.send(e)}_sendWithProtocol(e){return this._messageBuffer?this._messageBuffer._send(e):this._sendMessage(this._protocol.writeMessage(e))}send(e,...t){let[n,o]=this._replaceStreamingParams(t),r=this._sendWithProtocol(this._createInvocation(e,t,!0,o));return this._launchStreams(n,r),r}invoke(e,...t){let[n,o]=this._replaceStreamingParams(t),r=this._createInvocation(e,t,!1,o);return new Promise((e,t)=>{this._callbacks[r.invocationId]=(n,o)=>{if(o)return void t(o);n&&(n.type===a.G.Completion?n.error?t(Error(n.error)):e(n.result):t(Error(`Unexpected message type: ${n.type}`)))};let o=this._sendWithProtocol(r).catch(e=>{t(e),delete this._callbacks[r.invocationId]});this._launchStreams(n,o)})}on(e,t){e&&t&&(e=e.toLowerCase(),this._methods[e]||(this._methods[e]=[]),-1===this._methods[e].indexOf(t)&&this._methods[e].push(t))}off(e,t){if(!e)return;e=e.toLowerCase();let n=this._methods[e];if(n)if(t){let o=n.indexOf(t);-1!==o&&(n.splice(o,1),0===n.length&&delete this._methods[e])}else delete this._methods[e]}onclose(e){e&&this._closedCallbacks.push(e)}onreconnecting(e){e&&this._reconnectingCallbacks.push(e)}onreconnected(e){e&&this._reconnectedCallbacks.push(e)}_processIncomingData(e){if(this._cleanupTimeout(),this._receivedHandshakeResponse||(e=this._processHandshakeResponse(e),this._receivedHandshakeResponse=!0),e){for(let t of this._protocol.parseMessages(e,this._logger))if(!this._messageBuffer||this._messageBuffer._shouldProcessMessage(t))switch(t.type){case a.G.Invocation:this._invokeClientMethod(t).catch(e=>{this._logger.log(l.$.Error,`Invoke client method threw error: ${(0,s.WH)(e)}`)});break;case a.G.StreamItem:case a.G.Completion:{let e=this._callbacks[t.invocationId];if(e){t.type===a.G.Completion&&delete this._callbacks[t.invocationId];try{e(t)}catch(e){this._logger.log(l.$.Error,`Stream callback threw error: ${(0,s.WH)(e)}`)}}break}case a.G.Ping:break;case a.G.Close:{this._logger.log(l.$.Information,"Close message received from server.");let e=t.error?Error("Server returned an error on close: "+t.error):void 0;!0===t.allowReconnect?this.connection.stop(e):this._stopPromise=this._stopInternal(e);break}case a.G.Ack:this._messageBuffer&&this._messageBuffer._ack(t);break;case a.G.Sequence:this._messageBuffer&&this._messageBuffer._resetSequence(t);break;default:this._logger.log(l.$.Warning,`Invalid message type: ${t.type}.`)}}this._resetTimeoutPeriod()}_processHandshakeResponse(e){let t,n;try{[n,t]=this._handshakeProtocol.parseHandshakeResponse(e)}catch(n){let e="Error parsing handshake response: "+n;this._logger.log(l.$.Error,e);let t=Error(e);throw this._handshakeRejecter(t),t}if(t.error){let e="Server returned handshake error: "+t.error;this._logger.log(l.$.Error,e);let n=Error(e);throw this._handshakeRejecter(n),n}return this._logger.log(l.$.Debug,"Server handshake complete."),this._handshakeResolver(),n}_resetKeepAliveInterval(){this.connection.features.inherentKeepAlive||(this._nextKeepAlive=new Date().getTime()+this.keepAliveIntervalInMilliseconds,this._cleanupPingTimer())}_resetTimeoutPeriod(){if((!this.connection.features||!this.connection.features.inherentKeepAlive)&&(this._timeoutHandle=setTimeout(()=>this.serverTimeout(),this.serverTimeoutInMilliseconds),void 0===this._pingServerHandle)){let e=this._nextKeepAlive-new Date().getTime();e<0&&(e=0),this._pingServerHandle=setTimeout(async()=>{if(this._connectionState===o.Connected)try{await this._sendMessage(this._cachedPingMessage)}catch{this._cleanupPingTimer()}},e)}}serverTimeout(){this.connection.stop(Error("Server timeout elapsed without receiving a message from the server."))}async _invokeClientMethod(e){let t,n,o,r=e.target.toLowerCase(),s=this._methods[r];if(!s){this._logger.log(l.$.Warning,`No client method with the name '${r}' found.`),e.invocationId&&(this._logger.log(l.$.Warning,`No result given for '${r}' method and invocation ID '${e.invocationId}'.`),await this._sendWithProtocol(this._createCompletionMessage(e.invocationId,"Client didn't provide a result.",null)));return}let i=s.slice(),c=!!e.invocationId;for(let s of i)try{let i=t;t=await s.apply(this,e.arguments),c&&t&&i&&(this._logger.log(l.$.Error,`Multiple results provided for '${r}'. Sending error to server.`),o=this._createCompletionMessage(e.invocationId,"Client provided multiple results.",null)),n=void 0}catch(e){n=e,this._logger.log(l.$.Error,`A callback for the method '${r}' threw error '${e}'.`)}o?await this._sendWithProtocol(o):c?(n?o=this._createCompletionMessage(e.invocationId,`${n}`,null):void 0!==t?o=this._createCompletionMessage(e.invocationId,null,t):(this._logger.log(l.$.Warning,`No result given for '${r}' method and invocation ID '${e.invocationId}'.`),o=this._createCompletionMessage(e.invocationId,"Client didn't provide a result.",null)),await this._sendWithProtocol(o)):t&&this._logger.log(l.$.Error,`Result given for '${r}' method but server is not expecting a result.`)}_connectionClosed(e){this._logger.log(l.$.Debug,`HubConnection.connectionClosed(${e}) called while in state ${this._connectionState}.`),this._stopDuringStartError=this._stopDuringStartError||e||new c.lc("The underlying connection was closed before the hub handshake could complete."),this._handshakeResolver&&this._handshakeResolver(),this._cancelCallbacksWithError(e||Error("Invocation canceled due to the underlying connection being closed.")),this._cleanupTimeout(),this._cleanupPingTimer(),this._connectionState===o.Disconnecting?this._completeClose(e):this._connectionState===o.Connected&&this._reconnectPolicy?this._reconnect(e):this._connectionState===o.Connected&&this._completeClose(e)}_completeClose(e){if(this._connectionStarted){this._connectionState=o.Disconnected,this._connectionStarted=!1,this._messageBuffer&&(this._messageBuffer._dispose(null!=e?e:Error("Connection closed.")),this._messageBuffer=void 0),s.OD.isBrowser&&window.document.removeEventListener("freeze",this._freezeEventListener);try{this._closedCallbacks.forEach(t=>t.apply(this,[e]))}catch(t){this._logger.log(l.$.Error,`An onclose callback called with error '${e}' threw error '${t}'.`)}}}async _reconnect(e){let t=Date.now(),n=0,r=void 0!==e?e:Error("Attempting to reconnect due to a unknown error."),s=this._getNextRetryDelay(n++,0,r);if(null===s){this._logger.log(l.$.Debug,"Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt."),this._completeClose(e);return}if(this._connectionState=o.Reconnecting,e?this._logger.log(l.$.Information,`Connection reconnecting because of error '${e}'.`):this._logger.log(l.$.Information,"Connection reconnecting."),0!==this._reconnectingCallbacks.length){try{this._reconnectingCallbacks.forEach(t=>t.apply(this,[e]))}catch(t){this._logger.log(l.$.Error,`An onreconnecting callback called with error '${e}' threw error '${t}'.`)}if(this._connectionState!==o.Reconnecting)return void this._logger.log(l.$.Debug,"Connection left the reconnecting state in onreconnecting callback. Done reconnecting.")}for(;null!==s;){if(this._logger.log(l.$.Information,`Reconnect attempt number ${n} will start in ${s} ms.`),await new Promise(e=>{this._reconnectDelayHandle=setTimeout(e,s)}),this._reconnectDelayHandle=void 0,this._connectionState!==o.Reconnecting)return void this._logger.log(l.$.Debug,"Connection left the reconnecting state during reconnect delay. Done reconnecting.");try{if(await this._startInternal(),this._connectionState=o.Connected,this._logger.log(l.$.Information,"HubConnection reconnected successfully."),0!==this._reconnectedCallbacks.length)try{this._reconnectedCallbacks.forEach(e=>e.apply(this,[this.connection.connectionId]))}catch(e){this._logger.log(l.$.Error,`An onreconnected callback called with connectionId '${this.connection.connectionId}; threw error '${e}'.`)}return}catch(e){if(this._logger.log(l.$.Information,`Reconnect attempt failed because of error '${e}'.`),this._connectionState!==o.Reconnecting){this._logger.log(l.$.Debug,`Connection moved to the '${this._connectionState}' from the reconnecting state during reconnect attempt. Done reconnecting.`),this._connectionState===o.Disconnecting&&this._completeClose();return}r=e instanceof Error?e:Error(e.toString()),s=this._getNextRetryDelay(n++,Date.now()-t,r)}}this._logger.log(l.$.Information,`Reconnect retries have been exhausted after ${Date.now()-t} ms and ${n} failed attempts. Connection disconnecting.`),this._completeClose()}_getNextRetryDelay(e,t,n){try{return this._reconnectPolicy.nextRetryDelayInMilliseconds({elapsedMilliseconds:t,previousRetryCount:e,retryReason:n})}catch(n){return this._logger.log(l.$.Error,`IRetryPolicy.nextRetryDelayInMilliseconds(${e}, ${t}) threw error '${n}'.`),null}}_cancelCallbacksWithError(e){let t=this._callbacks;this._callbacks={},Object.keys(t).forEach(n=>{let o=t[n];try{o(null,e)}catch(t){this._logger.log(l.$.Error,`Stream 'error' callback called with '${e}' threw error: ${(0,s.WH)(t)}`)}})}_cleanupPingTimer(){this._pingServerHandle&&(clearTimeout(this._pingServerHandle),this._pingServerHandle=void 0)}_cleanupTimeout(){this._timeoutHandle&&clearTimeout(this._timeoutHandle)}_createInvocation(e,t,n,o){if(n)if(0!==o.length)return{target:e,arguments:t,streamIds:o,type:a.G.Invocation};else return{target:e,arguments:t,type:a.G.Invocation};{let n=this._invocationId;return(this._invocationId++,0!==o.length)?{target:e,arguments:t,invocationId:n.toString(),streamIds:o,type:a.G.Invocation}:{target:e,arguments:t,invocationId:n.toString(),type:a.G.Invocation}}}_launchStreams(e,t){if(0!==e.length)for(let n in t||(t=Promise.resolve()),e)e[n].subscribe({complete:()=>{t=t.then(()=>this._sendWithProtocol(this._createCompletionMessage(n)))},error:e=>{let o;o=e instanceof Error?e.message:e&&e.toString?e.toString():"Unknown error",t=t.then(()=>this._sendWithProtocol(this._createCompletionMessage(n,o)))},next:e=>{t=t.then(()=>this._sendWithProtocol(this._createStreamItemMessage(n,e)))}})}_replaceStreamingParams(e){let t=[],n=[];for(let o=0;o<e.length;o++){let r=e[o];if(this._isObservable(r)){let s=this._invocationId;this._invocationId++,t[s]=r,n.push(s.toString()),e.splice(o,1)}}return[t,n]}_isObservable(e){return e&&e.subscribe&&"function"==typeof e.subscribe}_createStreamInvocation(e,t,n){let o=this._invocationId;return(this._invocationId++,0!==n.length)?{target:e,arguments:t,invocationId:o.toString(),streamIds:n,type:a.G.StreamInvocation}:{target:e,arguments:t,invocationId:o.toString(),type:a.G.StreamInvocation}}_createCancelInvocation(e){return{invocationId:e,type:a.G.CancelInvocation}}_createStreamItemMessage(e,t){return{invocationId:e,item:t,type:a.G.StreamItem}}_createCompletionMessage(e,t,n){return t?{error:t,invocationId:e,type:a.G.Completion}:{invocationId:e,result:n,type:a.G.Completion}}_createCloseMessage(){return{type:a.G.Close}}}},9091:(e,t,n)=>{var o;n.d(t,{G:()=>o}),function(e){e[e.Invocation=1]="Invocation",e[e.StreamItem=2]="StreamItem",e[e.Completion=3]="Completion",e[e.StreamInvocation=4]="StreamInvocation",e[e.CancelInvocation=5]="CancelInvocation",e[e.Ping=6]="Ping",e[e.Close=7]="Close",e[e.Ack=8]="Ack",e[e.Sequence=9]="Sequence"}(o||(o={}))},9679:(e,t,n)=>{n.d(t,{B:()=>r});var o=n(6962);class r{constructor(){this.observers=[]}next(e){for(let t of this.observers)t.next(e)}error(e){for(let t of this.observers)t.error&&t.error(e)}complete(){for(let e of this.observers)e.complete&&e.complete()}subscribe(e){return this.observers.push(e),new o.YU(this,e)}}}}]);