"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[987],{1987:(t,e,o)=>{o.r(e),o.d(e,{AbortError:()=>s.lc,DefaultHttpClient:()=>p,HttpClient:()=>a,HttpError:()=>s.j$,HttpResponse:()=>i,HttpTransportType:()=>n,HubConnection:()=>d.q,HubConnectionBuilder:()=>D,HubConnectionState:()=>d.j,JsonHubProtocol:()=>I,LogLevel:()=>c.$,MessageType:()=>E.G,NullLogger:()=>k.Q,Subject:()=>L.B,TimeoutError:()=>s.MU,TransferFormat:()=>r,VERSION:()=>N.x});var n,r,s=o(4238);class i{constructor(t,e,o){this.statusCode=t,this.statusText=e,this.content=o}}class a{get(t,e){return this.send({...e,method:"GET",url:t})}post(t,e){return this.send({...e,method:"POST",url:t})}delete(t,e){return this.send({...e,method:"DELETE",url:t})}getCookieString(t){return""}}var c=o(6736),l=o(6962);class h extends a{constructor(t){if(super(),this._logger=t,"undefined"==typeof fetch||l.OD.isNode){let t=require;this._jar=new(t("tough-cookie")).CookieJar,"undefined"==typeof fetch?this._fetchType=t("node-fetch"):this._fetchType=fetch,this._fetchType=t("fetch-cookie")(this._fetchType,this._jar)}else this._fetchType=fetch.bind((0,l.We)());if("undefined"==typeof AbortController){let t=require;this._abortControllerType=t("abort-controller")}else this._abortControllerType=AbortController}async send(t){let e,o;if(t.abortSignal&&t.abortSignal.aborted)throw new s.lc;if(!t.method)throw Error("No method defined.");if(!t.url)throw Error("No url defined.");let n=new this._abortControllerType;t.abortSignal&&(t.abortSignal.onabort=()=>{n.abort(),e=new s.lc});let r=null;t.timeout&&(r=setTimeout(()=>{n.abort(),this._logger.log(c.$.Warning,"Timeout from HTTP request."),e=new s.MU},t.timeout)),""===t.content&&(t.content=void 0),t.content&&(t.headers=t.headers||{},(0,l.mw)(t.content)?t.headers["Content-Type"]="application/octet-stream":t.headers["Content-Type"]="text/plain;charset=UTF-8");try{o=await this._fetchType(t.url,{body:t.content,cache:"no-cache",credentials:!0===t.withCredentials?"include":"same-origin",headers:{"X-Requested-With":"XMLHttpRequest",...t.headers},method:t.method,mode:"cors",redirect:"follow",signal:n.signal})}catch(t){if(e)throw e;throw this._logger.log(c.$.Warning,`Error from HTTP request. ${t}.`),t}finally{r&&clearTimeout(r),t.abortSignal&&(t.abortSignal.onabort=null)}if(!o.ok){let t=await u(o,"text");throw new s.j$(t||o.statusText,o.status)}let a=u(o,t.responseType),h=await a;return new i(o.status,o.statusText,h)}getCookieString(t){let e="";return l.OD.isNode&&this._jar&&this._jar.getCookies(t,(t,o)=>e=o.join("; ")),e}}function u(t,e){let o;switch(e){case"arraybuffer":o=t.arrayBuffer();break;case"text":default:o=t.text();break;case"blob":case"document":case"json":throw Error(`${e} is not supported.`)}return o}class g extends a{constructor(t){super(),this._logger=t}send(t){return t.abortSignal&&t.abortSignal.aborted?Promise.reject(new s.lc):t.method?t.url?new Promise((e,o)=>{let n=new XMLHttpRequest;n.open(t.method,t.url,!0),n.withCredentials=void 0===t.withCredentials||t.withCredentials,n.setRequestHeader("X-Requested-With","XMLHttpRequest"),""===t.content&&(t.content=void 0),t.content&&((0,l.mw)(t.content)?n.setRequestHeader("Content-Type","application/octet-stream"):n.setRequestHeader("Content-Type","text/plain;charset=UTF-8"));let r=t.headers;r&&Object.keys(r).forEach(t=>{n.setRequestHeader(t,r[t])}),t.responseType&&(n.responseType=t.responseType),t.abortSignal&&(t.abortSignal.onabort=()=>{n.abort(),o(new s.lc)}),t.timeout&&(n.timeout=t.timeout),n.onload=()=>{t.abortSignal&&(t.abortSignal.onabort=null),n.status>=200&&n.status<300?e(new i(n.status,n.statusText,n.response||n.responseText)):o(new s.j$(n.response||n.responseText||n.statusText,n.status))},n.onerror=()=>{this._logger.log(c.$.Warning,`Error from HTTP request. ${n.status}: ${n.statusText}.`),o(new s.j$(n.statusText,n.status))},n.ontimeout=()=>{this._logger.log(c.$.Warning,"Timeout from HTTP request."),o(new s.MU)},n.send(t.content)}):Promise.reject(Error("No url defined.")):Promise.reject(Error("No method defined."))}}class p extends a{constructor(t){if(super(),"undefined"!=typeof fetch||l.OD.isNode)this._httpClient=new h(t);else if("undefined"!=typeof XMLHttpRequest)this._httpClient=new g(t);else throw Error("No usable HttpClient found.")}send(t){return t.abortSignal&&t.abortSignal.aborted?Promise.reject(new s.lc):t.method?t.url?this._httpClient.send(t):Promise.reject(Error("No url defined.")):Promise.reject(Error("No method defined."))}getCookieString(t){return this._httpClient.getCookieString(t)}}var d=o(8846);let _=[0,2e3,1e4,3e4,null];class f{constructor(t){this._retryDelays=void 0!==t?[...t,null]:_}nextRetryDelayInMilliseconds(t){return this._retryDelays[t.previousRetryCount]}}class w{}w.Authorization="Authorization",w.Cookie="Cookie";class b extends a{constructor(t,e){super(),this._innerClient=t,this._accessTokenFactory=e}async send(t){let e=!0;this._accessTokenFactory&&(!this._accessToken||t.url&&t.url.indexOf("/negotiate?")>0)&&(e=!1,this._accessToken=await this._accessTokenFactory()),this._setAuthorizationHeader(t);let o=await this._innerClient.send(t);return e&&401===o.statusCode&&this._accessTokenFactory?(this._accessToken=await this._accessTokenFactory(),this._setAuthorizationHeader(t),await this._innerClient.send(t)):o}_setAuthorizationHeader(t){t.headers||(t.headers={}),this._accessToken?t.headers[w.Authorization]=`Bearer ${this._accessToken}`:this._accessTokenFactory&&t.headers[w.Authorization]&&delete t.headers[w.Authorization]}getCookieString(t){return this._innerClient.getCookieString(t)}}!function(t){t[t.None=0]="None",t[t.WebSockets=1]="WebSockets",t[t.ServerSentEvents=2]="ServerSentEvents",t[t.LongPolling=4]="LongPolling"}(n||(n={})),function(t){t[t.Text=1]="Text",t[t.Binary=2]="Binary"}(r||(r={}));class m{constructor(){this._isAborted=!1,this.onabort=null}abort(){!this._isAborted&&(this._isAborted=!0,this.onabort&&this.onabort())}get signal(){return this}get aborted(){return this._isAborted}}class y{get pollAborted(){return this._pollAbort.aborted}constructor(t,e,o){this._httpClient=t,this._logger=e,this._pollAbort=new m,this._options=o,this._running=!1,this.onreceive=null,this.onclose=null}async connect(t,e){if(l.z6.isRequired(t,"url"),l.z6.isRequired(e,"transferFormat"),l.z6.isIn(e,r,"transferFormat"),this._url=t,this._logger.log(c.$.Trace,"(LongPolling transport) Connecting."),e===r.Binary&&"undefined"!=typeof XMLHttpRequest&&"string"!=typeof new XMLHttpRequest().responseType)throw Error("Binary protocols over XmlHttpRequest not implementing advanced features are not supported.");let[o,n]=(0,l.AL)(),i={[o]:n,...this._options.headers},a={abortSignal:this._pollAbort.signal,headers:i,timeout:1e5,withCredentials:this._options.withCredentials};e===r.Binary&&(a.responseType="arraybuffer");let h=`${t}&_=${Date.now()}`;this._logger.log(c.$.Trace,`(LongPolling transport) polling: ${h}.`);let u=await this._httpClient.get(h,a);200!==u.statusCode?(this._logger.log(c.$.Error,`(LongPolling transport) Unexpected response code: ${u.statusCode}.`),this._closeError=new s.j$(u.statusText||"",u.statusCode),this._running=!1):this._running=!0,this._receiving=this._poll(this._url,a)}async _poll(t,e){try{for(;this._running;)try{let o=`${t}&_=${Date.now()}`;this._logger.log(c.$.Trace,`(LongPolling transport) polling: ${o}.`);let n=await this._httpClient.get(o,e);204===n.statusCode?(this._logger.log(c.$.Information,"(LongPolling transport) Poll terminated by server."),this._running=!1):200!==n.statusCode?(this._logger.log(c.$.Error,`(LongPolling transport) Unexpected response code: ${n.statusCode}.`),this._closeError=new s.j$(n.statusText||"",n.statusCode),this._running=!1):n.content?(this._logger.log(c.$.Trace,`(LongPolling transport) data received. ${(0,l.Gp)(n.content,this._options.logMessageContent)}.`),this.onreceive&&this.onreceive(n.content)):this._logger.log(c.$.Trace,"(LongPolling transport) Poll timed out, reissuing.")}catch(t){this._running?t instanceof s.MU?this._logger.log(c.$.Trace,"(LongPolling transport) Poll timed out, reissuing."):(this._closeError=t,this._running=!1):this._logger.log(c.$.Trace,`(LongPolling transport) Poll errored after shutdown: ${t.message}`)}}finally{this._logger.log(c.$.Trace,"(LongPolling transport) Polling complete."),this.pollAborted||this._raiseOnClose()}}async send(t){return this._running?(0,l._z)(this._logger,"LongPolling",this._httpClient,this._url,t,this._options):Promise.reject(Error("Cannot send until the transport is connected"))}async stop(){this._logger.log(c.$.Trace,"(LongPolling transport) Stopping polling."),this._running=!1,this._pollAbort.abort();try{let t;await this._receiving,this._logger.log(c.$.Trace,`(LongPolling transport) sending DELETE request to ${this._url}.`);let e={},[o,n]=(0,l.AL)();e[o]=n;let r={headers:{...e,...this._options.headers},timeout:this._options.timeout,withCredentials:this._options.withCredentials};try{await this._httpClient.delete(this._url,r)}catch(e){t=e}t?t instanceof s.j$&&(404===t.statusCode?this._logger.log(c.$.Trace,"(LongPolling transport) A 404 response was returned from sending a DELETE request."):this._logger.log(c.$.Trace,`(LongPolling transport) Error sending a DELETE request: ${t}`)):this._logger.log(c.$.Trace,"(LongPolling transport) DELETE request accepted.")}finally{this._logger.log(c.$.Trace,"(LongPolling transport) Stop finished."),this._raiseOnClose()}}_raiseOnClose(){if(this.onclose){let t="(LongPolling transport) Firing onclose event.";this._closeError&&(t+=" Error: "+this._closeError),this._logger.log(c.$.Trace,t),this.onclose(this._closeError)}}}class S{constructor(t,e,o,n){this._httpClient=t,this._accessToken=e,this._logger=o,this._options=n,this.onreceive=null,this.onclose=null}async connect(t,e){return l.z6.isRequired(t,"url"),l.z6.isRequired(e,"transferFormat"),l.z6.isIn(e,r,"transferFormat"),this._logger.log(c.$.Trace,"(SSE transport) Connecting."),this._url=t,this._accessToken&&(t+=(0>t.indexOf("?")?"?":"&")+`access_token=${encodeURIComponent(this._accessToken)}`),new Promise((o,n)=>{let s,i=!1;if(e!==r.Text)return void n(Error("The Server-Sent Events transport only supports the 'Text' transfer format"));if(l.OD.isBrowser||l.OD.isWebWorker)s=new this._options.EventSource(t,{withCredentials:this._options.withCredentials});else{let e=this._httpClient.getCookieString(t),o={};o.Cookie=e;let[n,r]=(0,l.AL)();o[n]=r,s=new this._options.EventSource(t,{withCredentials:this._options.withCredentials,headers:{...o,...this._options.headers}})}try{s.onmessage=t=>{if(this.onreceive)try{this._logger.log(c.$.Trace,`(SSE transport) data received. ${(0,l.Gp)(t.data,this._options.logMessageContent)}.`),this.onreceive(t.data)}catch(t){this._close(t);return}},s.onerror=t=>{i?this._close():n(Error("EventSource failed to connect. The connection could not be found on the server, either the connection ID is not present on the server, or a proxy is refusing/buffering the connection. If you have multiple servers check that sticky sessions are enabled."))},s.onopen=()=>{this._logger.log(c.$.Information,`SSE connected to ${this._url}`),this._eventSource=s,i=!0,o()}}catch(t){n(t);return}})}async send(t){return this._eventSource?(0,l._z)(this._logger,"SSE",this._httpClient,this._url,t,this._options):Promise.reject(Error("Cannot send until the transport is connected"))}stop(){return this._close(),Promise.resolve()}_close(t){this._eventSource&&(this._eventSource.close(),this._eventSource=void 0,this.onclose&&this.onclose(t))}}class C{constructor(t,e,o,n,r,s){this._logger=o,this._accessTokenFactory=e,this._logMessageContent=n,this._webSocketConstructor=r,this._httpClient=t,this.onreceive=null,this.onclose=null,this._headers=s}async connect(t,e){let o;return l.z6.isRequired(t,"url"),l.z6.isRequired(e,"transferFormat"),l.z6.isIn(e,r,"transferFormat"),this._logger.log(c.$.Trace,"(WebSockets transport) Connecting."),this._accessTokenFactory&&(o=await this._accessTokenFactory()),new Promise((n,s)=>{let i;t=t.replace(/^http/,"ws");let a=this._httpClient.getCookieString(t),h=!1;if(l.OD.isNode||l.OD.isReactNative){let e={},[n,r]=(0,l.AL)();e[n]=r,o&&(e[w.Authorization]=`Bearer ${o}`),a&&(e[w.Cookie]=a),i=new this._webSocketConstructor(t,void 0,{headers:{...e,...this._headers}})}else o&&(t+=(0>t.indexOf("?")?"?":"&")+`access_token=${encodeURIComponent(o)}`);i||(i=new this._webSocketConstructor(t)),e===r.Binary&&(i.binaryType="arraybuffer"),i.onopen=e=>{this._logger.log(c.$.Information,`WebSocket connected to ${t}.`),this._webSocket=i,h=!0,n()},i.onerror=t=>{let e=null;e="undefined"!=typeof ErrorEvent&&t instanceof ErrorEvent?t.error:"There was an error with the transport",this._logger.log(c.$.Information,`(WebSockets transport) ${e}.`)},i.onmessage=t=>{if(this._logger.log(c.$.Trace,`(WebSockets transport) data received. ${(0,l.Gp)(t.data,this._logMessageContent)}.`),this.onreceive)try{this.onreceive(t.data)}catch(t){this._close(t);return}},i.onclose=t=>{if(h)this._close(t);else s(Error("undefined"!=typeof ErrorEvent&&t instanceof ErrorEvent?t.error:"WebSocket failed to connect. The connection could not be found on the server, either the endpoint may not be a SignalR endpoint, the connection ID is not present on the server, or there is a proxy blocking WebSockets. If you have multiple servers check that sticky sessions are enabled."))}})}send(t){return this._webSocket&&this._webSocket.readyState===this._webSocketConstructor.OPEN?(this._logger.log(c.$.Trace,`(WebSockets transport) sending data. ${(0,l.Gp)(t,this._logMessageContent)}.`),this._webSocket.send(t),Promise.resolve()):Promise.reject("WebSocket is not in the OPEN state")}stop(){return this._webSocket&&this._close(void 0),Promise.resolve()}_close(t){this._webSocket&&(this._webSocket.onclose=()=>{},this._webSocket.onmessage=()=>{},this._webSocket.onerror=()=>{},this._webSocket.close(),this._webSocket=void 0),this._logger.log(c.$.Trace,"(WebSockets transport) socket closed."),this.onclose&&(this._isCloseEvent(t)&&(!1===t.wasClean||1e3!==t.code)?this.onclose(Error(`WebSocket closed with status code: ${t.code} (${t.reason||"no reason given"}).`)):t instanceof Error?this.onclose(t):this.onclose())}_isCloseEvent(t){return t&&"boolean"==typeof t.wasClean&&"number"==typeof t.code}}class v{constructor(t,e={}){if(this._stopPromiseResolver=()=>{},this.features={},this._negotiateVersion=1,l.z6.isRequired(t,"url"),this._logger=(0,l.h)(e.logger),this.baseUrl=this._resolveUrl(t),(e=e||{}).logMessageContent=void 0!==e.logMessageContent&&e.logMessageContent,"boolean"==typeof e.withCredentials||void 0===e.withCredentials)e.withCredentials=void 0===e.withCredentials||e.withCredentials;else throw Error("withCredentials option was not a 'boolean' or 'undefined' value");e.timeout=void 0===e.timeout?1e5:e.timeout;let o=null,n=null;if(l.OD.isNode&&1){let t=require;o=t("ws"),n=t("eventsource")}l.OD.isNode||"undefined"==typeof WebSocket||e.WebSocket?l.OD.isNode&&!e.WebSocket&&o&&(e.WebSocket=o):e.WebSocket=WebSocket,l.OD.isNode||"undefined"==typeof EventSource||e.EventSource?l.OD.isNode&&!e.EventSource&&void 0!==n&&(e.EventSource=n):e.EventSource=EventSource,this._httpClient=new b(e.httpClient||new p(this._logger),e.accessTokenFactory),this._connectionState="Disconnected",this._connectionStarted=!1,this._options=e,this.onreceive=null,this.onclose=null}async start(t){if(t=t||r.Binary,l.z6.isIn(t,r,"transferFormat"),this._logger.log(c.$.Debug,`Starting connection with transfer format '${r[t]}'.`),"Disconnected"!==this._connectionState)return Promise.reject(Error("Cannot start an HttpConnection that is not in the 'Disconnected' state."));if(this._connectionState="Connecting",this._startInternalPromise=this._startInternal(t),await this._startInternalPromise,"Disconnecting"===this._connectionState){let t="Failed to start the HttpConnection before stop() was called.";return this._logger.log(c.$.Error,t),await this._stopPromise,Promise.reject(new s.lc(t))}if("Connected"!==this._connectionState){let t="HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!";return this._logger.log(c.$.Error,t),Promise.reject(new s.lc(t))}this._connectionStarted=!0}send(t){return"Connected"!==this._connectionState?Promise.reject(Error("Cannot send data if the connection is not in the 'Connected' State.")):(this._sendQueue||(this._sendQueue=new T(this.transport)),this._sendQueue.send(t))}async stop(t){return"Disconnected"===this._connectionState?(this._logger.log(c.$.Debug,`Call to HttpConnection.stop(${t}) ignored because the connection is already in the disconnected state.`),Promise.resolve()):"Disconnecting"===this._connectionState?(this._logger.log(c.$.Debug,`Call to HttpConnection.stop(${t}) ignored because the connection is already in the disconnecting state.`),this._stopPromise):void(this._connectionState="Disconnecting",this._stopPromise=new Promise(t=>{this._stopPromiseResolver=t}),await this._stopInternal(t),await this._stopPromise)}async _stopInternal(t){this._stopError=t;try{await this._startInternalPromise}catch(t){}if(this.transport){try{await this.transport.stop()}catch(t){this._logger.log(c.$.Error,`HttpConnection.transport.stop() threw error '${t}'.`),this._stopConnection()}this.transport=void 0}else this._logger.log(c.$.Debug,"HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.")}async _startInternal(t){let e=this.baseUrl;this._accessTokenFactory=this._options.accessTokenFactory,this._httpClient._accessTokenFactory=this._accessTokenFactory;try{if(this._options.skipNegotiation)if(this._options.transport===n.WebSockets)this.transport=this._constructTransport(n.WebSockets),await this._startTransport(e,t);else throw Error("Negotiation can only be skipped when using the WebSocket transport directly.");else{let o=null,n=0;do{if(o=await this._getNegotiationResponse(e),"Disconnecting"===this._connectionState||"Disconnected"===this._connectionState)throw new s.lc("The connection was stopped during negotiation.");if(o.error)throw Error(o.error);if(o.ProtocolVersion)throw Error("Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.");if(o.url&&(e=o.url),o.accessToken){let t=o.accessToken;this._accessTokenFactory=()=>t,this._httpClient._accessToken=t,this._httpClient._accessTokenFactory=void 0}n++}while(o.url&&n<100);if(100===n&&o.url)throw Error("Negotiate redirection limit exceeded.");await this._createTransport(e,this._options.transport,o,t)}this.transport instanceof y&&(this.features.inherentKeepAlive=!0),"Connecting"===this._connectionState&&(this._logger.log(c.$.Debug,"The HttpConnection connected successfully."),this._connectionState="Connected")}catch(t){return this._logger.log(c.$.Error,"Failed to start the connection: "+t),this._connectionState="Disconnected",this.transport=void 0,this._stopPromiseResolver(),Promise.reject(t)}}async _getNegotiationResponse(t){let e={},[o,n]=(0,l.AL)();e[o]=n;let r=this._resolveNegotiateUrl(t);this._logger.log(c.$.Debug,`Sending negotiation request: ${r}.`);try{let t=await this._httpClient.post(r,{content:"",headers:{...e,...this._options.headers},timeout:this._options.timeout,withCredentials:this._options.withCredentials});if(200!==t.statusCode)return Promise.reject(Error(`Unexpected status code returned from negotiate '${t.statusCode}'`));let o=JSON.parse(t.content);if((!o.negotiateVersion||o.negotiateVersion<1)&&(o.connectionToken=o.connectionId),o.useStatefulReconnect&&!0!==this._options._useStatefulReconnect)return Promise.reject(new s.YW("Client didn't negotiate Stateful Reconnect but the server did."));return o}catch(e){let t="Failed to complete negotiation with the server: "+e;return e instanceof s.j$&&404===e.statusCode&&(t+=" Either this is not a SignalR endpoint or there is a proxy blocking the connection."),this._logger.log(c.$.Error,t),Promise.reject(new s.YW(t))}}_createConnectUrl(t,e){return e?t+(-1===t.indexOf("?")?"?":"&")+`id=${e}`:t}async _createTransport(t,e,o,r){let i=this._createConnectUrl(t,o.connectionToken);if(this._isITransport(e)){this._logger.log(c.$.Debug,"Connection was provided an instance of ITransport, using that directly."),this.transport=e,await this._startTransport(i,r),this.connectionId=o.connectionId;return}let a=[],l=o.availableTransports||[],h=o;for(let o of l){let l=this._resolveTransportOrError(o,e,r,(null==h?void 0:h.useStatefulReconnect)===!0);if(l instanceof Error)a.push(`${o.transport} failed:`),a.push(l);else if(this._isITransport(l)){if(this.transport=l,!h){try{h=await this._getNegotiationResponse(t)}catch(t){return Promise.reject(t)}i=this._createConnectUrl(t,h.connectionToken)}try{await this._startTransport(i,r),this.connectionId=h.connectionId;return}catch(t){if(this._logger.log(c.$.Error,`Failed to start the transport '${o.transport}': ${t}`),h=void 0,a.push(new s.az(`${o.transport} failed: ${t}`,n[o.transport])),"Connecting"!==this._connectionState){let t="Failed to select transport before stop() was called.";return this._logger.log(c.$.Debug,t),Promise.reject(new s.lc(t))}}}}return a.length>0?Promise.reject(new s.tJ(`Unable to connect to the server with any of the available transports. ${a.join(" ")}`,a)):Promise.reject(Error("None of the transports supported by the client are supported by the server."))}_constructTransport(t){switch(t){case n.WebSockets:if(!this._options.WebSocket)throw Error("'WebSocket' is not supported in your environment.");return new C(this._httpClient,this._accessTokenFactory,this._logger,this._options.logMessageContent,this._options.WebSocket,this._options.headers||{});case n.ServerSentEvents:if(!this._options.EventSource)throw Error("'EventSource' is not supported in your environment.");return new S(this._httpClient,this._httpClient._accessToken,this._logger,this._options);case n.LongPolling:return new y(this._httpClient,this._logger,this._options);default:throw Error(`Unknown transport: ${t}.`)}}_startTransport(t,e){return this.transport.onreceive=this.onreceive,this.features.reconnect?this.transport.onclose=async o=>{let n=!1;if(!this.features.reconnect)return void this._stopConnection(o);try{this.features.disconnected(),await this.transport.connect(t,e),await this.features.resend()}catch{n=!0}n&&this._stopConnection(o)}:this.transport.onclose=t=>this._stopConnection(t),this.transport.connect(t,e)}_resolveTransportOrError(t,e,o,i){var a,l;let h=n[t.transport];if(null==h)return this._logger.log(c.$.Debug,`Skipping transport '${t.transport}' because it is not supported by this client.`),Error(`Skipping transport '${t.transport}' because it is not supported by this client.`);if(a=e,l=h,a&&(l&a)==0)return this._logger.log(c.$.Debug,`Skipping transport '${n[h]}' because it was disabled by the client.`),new s.Y3(`'${n[h]}' is disabled by the client.`,h);if(!(t.transferFormats.map(t=>r[t]).indexOf(o)>=0))return this._logger.log(c.$.Debug,`Skipping transport '${n[h]}' because it does not support the requested transfer format '${r[o]}'.`),Error(`'${n[h]}' does not support ${r[o]}.`);if(h===n.WebSockets&&!this._options.WebSocket||h===n.ServerSentEvents&&!this._options.EventSource)return this._logger.log(c.$.Debug,`Skipping transport '${n[h]}' because it is not supported in your environment.'`),new s.zN(`'${n[h]}' is not supported in your environment.`,h);this._logger.log(c.$.Debug,`Selecting transport '${n[h]}'.`);try{return this.features.reconnect=h===n.WebSockets?i:void 0,this._constructTransport(h)}catch(t){return t}}_isITransport(t){return t&&"object"==typeof t&&"connect"in t}_stopConnection(t){if(this._logger.log(c.$.Debug,`HttpConnection.stopConnection(${t}) called while in state ${this._connectionState}.`),this.transport=void 0,t=this._stopError||t,this._stopError=void 0,"Disconnected"===this._connectionState)return void this._logger.log(c.$.Debug,`Call to HttpConnection.stopConnection(${t}) was ignored because the connection is already in the disconnected state.`);if("Connecting"===this._connectionState)throw this._logger.log(c.$.Warning,`Call to HttpConnection.stopConnection(${t}) was ignored because the connection is still in the connecting state.`),Error(`HttpConnection.stopConnection(${t}) was called while the connection is still in the connecting state.`);if("Disconnecting"===this._connectionState&&this._stopPromiseResolver(),t?this._logger.log(c.$.Error,`Connection disconnected with error '${t}'.`):this._logger.log(c.$.Information,"Connection disconnected."),this._sendQueue&&(this._sendQueue.stop().catch(t=>{this._logger.log(c.$.Error,`TransportSendQueue.stop() threw error '${t}'.`)}),this._sendQueue=void 0),this.connectionId=void 0,this._connectionState="Disconnected",this._connectionStarted){this._connectionStarted=!1;try{this.onclose&&this.onclose(t)}catch(e){this._logger.log(c.$.Error,`HttpConnection.onclose(${t}) threw error '${e}'.`)}}}_resolveUrl(t){if(0===t.lastIndexOf("https://",0)||0===t.lastIndexOf("http://",0))return t;if(!l.OD.isBrowser)throw Error(`Cannot resolve '${t}'.`);let e=window.document.createElement("a");return e.href=t,this._logger.log(c.$.Information,`Normalizing '${t}' to '${e.href}'.`),e.href}_resolveNegotiateUrl(t){let e=new URL(t);e.pathname.endsWith("/")?e.pathname+="negotiate":e.pathname+="/negotiate";let o=new URLSearchParams(e.searchParams);return o.has("negotiateVersion")||o.append("negotiateVersion",this._negotiateVersion.toString()),o.has("useStatefulReconnect")?"true"===o.get("useStatefulReconnect")&&(this._options._useStatefulReconnect=!0):!0===this._options._useStatefulReconnect&&o.append("useStatefulReconnect","true"),e.search=o.toString(),e.toString()}}class T{constructor(t){this._transport=t,this._buffer=[],this._executing=!0,this._sendBufferedData=new $,this._transportResult=new $,this._sendLoopPromise=this._sendLoop()}send(t){return this._bufferData(t),this._transportResult||(this._transportResult=new $),this._transportResult.promise}stop(){return this._executing=!1,this._sendBufferedData.resolve(),this._sendLoopPromise}_bufferData(t){if(this._buffer.length&&typeof this._buffer[0]!=typeof t)throw Error(`Expected data to be of type ${typeof this._buffer} but was of type ${typeof t}`);this._buffer.push(t),this._sendBufferedData.resolve()}async _sendLoop(){for(;;){if(await this._sendBufferedData.promise,!this._executing){this._transportResult&&this._transportResult.reject("Connection stopped.");break}this._sendBufferedData=new $;let t=this._transportResult;this._transportResult=void 0;let e="string"==typeof this._buffer[0]?this._buffer.join(""):T._concatBuffers(this._buffer);this._buffer.length=0;try{await this._transport.send(e),t.resolve()}catch(e){t.reject(e)}}}static _concatBuffers(t){let e=new Uint8Array(t.map(t=>t.byteLength).reduce((t,e)=>t+e)),o=0;for(let n of t)e.set(new Uint8Array(n),o),o+=n.byteLength;return e.buffer}}class ${constructor(){this.promise=new Promise((t,e)=>([this._resolver,this._rejecter]=[t,e]))}resolve(){this._resolver()}reject(t){this._rejecter(t)}}var E=o(9091),k=o(6622),P=o(8098);class I{constructor(){this.name="json",this.version=2,this.transferFormat=r.Text}parseMessages(t,e){if("string"!=typeof t)throw Error("Invalid input for JSON hub protocol. Expected a string.");if(!t)return[];null===e&&(e=k.Q.instance);let o=P.s.parse(t),n=[];for(let t of o){let o=JSON.parse(t);if("number"!=typeof o.type)throw Error("Invalid payload.");switch(o.type){case E.G.Invocation:this._isInvocationMessage(o);break;case E.G.StreamItem:this._isStreamItemMessage(o);break;case E.G.Completion:this._isCompletionMessage(o);break;case E.G.Ping:case E.G.Close:break;case E.G.Ack:this._isAckMessage(o);break;case E.G.Sequence:this._isSequenceMessage(o);break;default:e.log(c.$.Information,"Unknown message type '"+o.type+"' ignored.");continue}n.push(o)}return n}writeMessage(t){return P.s.write(JSON.stringify(t))}_isInvocationMessage(t){this._assertNotEmptyString(t.target,"Invalid payload for Invocation message."),void 0!==t.invocationId&&this._assertNotEmptyString(t.invocationId,"Invalid payload for Invocation message.")}_isStreamItemMessage(t){if(this._assertNotEmptyString(t.invocationId,"Invalid payload for StreamItem message."),void 0===t.item)throw Error("Invalid payload for StreamItem message.")}_isCompletionMessage(t){if(t.result&&t.error)throw Error("Invalid payload for Completion message.");!t.result&&t.error&&this._assertNotEmptyString(t.error,"Invalid payload for Completion message."),this._assertNotEmptyString(t.invocationId,"Invalid payload for Completion message.")}_isAckMessage(t){if("number"!=typeof t.sequenceId)throw Error("Invalid SequenceId for Ack message.")}_isSequenceMessage(t){if("number"!=typeof t.sequenceId)throw Error("Invalid SequenceId for Sequence message.")}_assertNotEmptyString(t,e){if("string"!=typeof t||""===t)throw Error(e)}}let R={trace:c.$.Trace,debug:c.$.Debug,info:c.$.Information,information:c.$.Information,warn:c.$.Warning,warning:c.$.Warning,error:c.$.Error,critical:c.$.Critical,none:c.$.None};class D{configureLogging(t){if(l.z6.isRequired(t,"logging"),void 0!==t.log)this.logger=t;else if("string"==typeof t){let e=function(t){let e=R[t.toLowerCase()];if(void 0!==e)return e;throw Error(`Unknown log level: ${t}`)}(t);this.logger=new l.Cr(e)}else this.logger=new l.Cr(t);return this}withUrl(t,e){return l.z6.isRequired(t,"url"),l.z6.isNotEmpty(t,"url"),this.url=t,"object"==typeof e?this.httpConnectionOptions={...this.httpConnectionOptions,...e}:this.httpConnectionOptions={...this.httpConnectionOptions,transport:e},this}withHubProtocol(t){return l.z6.isRequired(t,"protocol"),this.protocol=t,this}withAutomaticReconnect(t){if(this.reconnectPolicy)throw Error("A reconnectPolicy has already been set.");return t?Array.isArray(t)?this.reconnectPolicy=new f(t):this.reconnectPolicy=t:this.reconnectPolicy=new f,this}withServerTimeout(t){return l.z6.isRequired(t,"milliseconds"),this._serverTimeoutInMilliseconds=t,this}withKeepAliveInterval(t){return l.z6.isRequired(t,"milliseconds"),this._keepAliveIntervalInMilliseconds=t,this}withStatefulReconnect(t){return void 0===this.httpConnectionOptions&&(this.httpConnectionOptions={}),this.httpConnectionOptions._useStatefulReconnect=!0,this._statefulReconnectBufferSize=null==t?void 0:t.bufferSize,this}build(){let t=this.httpConnectionOptions||{};if(void 0===t.logger&&(t.logger=this.logger),!this.url)throw Error("The 'HubConnectionBuilder.withUrl' method must be called before building the connection.");let e=new v(this.url,t);return d.q.create(e,this.logger||k.Q.instance,this.protocol||new I,this.reconnectPolicy,this._serverTimeoutInMilliseconds,this._keepAliveIntervalInMilliseconds,this._statefulReconnectBufferSize)}}var L=o(9679),N=o(5764)}}]);