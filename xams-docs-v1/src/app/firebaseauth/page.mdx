import firebaseAuth from '@/images/firebase_auth.png'
export const metadata = {
  title: 'Firebase Authentication',
  description: 'How to implement Firebase Authentication in Xams',
}

# Firebase Authentication

Integrate Firebase Authentication with your Xams application for secure user management. {{ className: 'lead' }}

Xams provides built-in Firebase authentication support with a customizable login page and comprehensive auth flows including multi-factor authentication (MFA). {{ className: 'lead' }}

The fastest way to get started is to use the [Xams Firebase template](https://github.com/ixetanet/xams-template-firebase) which includes a complete example with React frontend.

<DocImage image={firebaseAuth} />

## Install Required Packages

Install the FirebaseAdmin SDK and Xams.Firebase NuGet packages.

```bash
dotnet add package FirebaseAdmin
dotnet add package Xams.Firebase
```

## Download Service Account Key

Generate and configure your Firebase service account private key:

1. Navigate to your Firebase project in the Firebase console
2. Open **Project settings**
3. Select the **Service accounts** tab
4. Click **Generate new private key** in the Firebase Admin SDK section
5. Confirm to download the JSON key file
6. Add the JSON file to your project (e.g., in a `keys` folder)
7. Configure the file to copy to output directory in your project settings

## Configure User Entity

Add the required Firebase fields to your User entity:

```c# {{ title: 'Project / Entities / AppUser.cs' }}
public class AppUser : User
{
    [UIRequired]
    [MaxLength(100)]
    public string? EmailAddress { get; set; }

    [UIRequired]
    [MaxLength(50)]
    public string? FirebaseId { get; set; }
}
```

Register AppUser in your DbContext:

```c# {{ title: 'Project / DataContext.cs' }}
public class DataContext : XamsDbContext<AppUser>
{
    ...
}
```

## Configure Authentication

Add Firebase authentication to Program.cs:

```c# {{ title: 'Project / Program.cs' }}
builder.Services.AddAuthorization();

FirebaseApp.Create(options: new AppOptions()
{
    Credential = GoogleCredential.FromFile($"./keys/firebase-{environment.ToLower()}.json")
});

builder.Services
    .AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.AddXamsFirebaseAuth(firebaseProjectId);
        options.AddXamsSignalRAuth();
    });
```

## Configure API Endpoints

Configure the Xams API with Firebase support in Program.cs:

```c# {{ title: 'Project / Program.cs' }}
var app = builder.Build();

app.UseHttpsRedirection();
app.UseAuthentication();
app.UseAuthorization();

// Add proxy for Firebase auth redirects (before static files)
// Enables proper redirect handling on custom domains
// Reference: https://firebase.google.com/docs/auth/web/redirect-best-practices
app.AddFirebaseAuthProxy(firebaseProjectId);

app.UseStaticFiles();

// Configure Xams API with Firebase integration
app.AddXamsApi(options =>
{
    options.UseDashboard = true;
    options.RequireAuthorization = true;
    options.GetUserId = UserUtil.GetUserId;
    options.FirebaseConfig = builder.Configuration.GetSection("FirebaseConfig").Get<FirebaseConfig>();

});

// Add Firebase-specific endpoints (e.g., email verification)
app.AddXamsFirebaseApi();
```

## User Authentication Helper

Create a UserUtil class to handle user authentication, automatically creating Xams users from Firebase claims:

```c# {{ title: 'Project / UserUtil.cs' }}
public class UserUtil
{
    private static ConcurrentDictionary<string, Guid> _users = new();
    public static async Task<Guid> GetUserId(HttpContext httpContext)
    {
        var userIdClaim = httpContext.User.Claims
            .Where(x => x.Type == ClaimTypes.NameIdentifier)
            .Select(x => x.Value).FirstOrDefault();
        var emailClaim = httpContext.User.Claims
            .Where(x => x.Type == ClaimTypes.Email)
            .Select(x => x.Value).FirstOrDefault();

        if (userIdClaim == null)
        {
            throw new Exception("UserId not found");
        }

        using (var db = new DataContext())
        {
            var userId = await GetUserId(db, userIdClaim, emailClaim);
            try
            {
                // Attempt to create the user
                if (userId == Guid.Empty)
                {
                    userId = await CreateUser(db, userIdClaim, emailClaim);
                }
            }
            catch (Exception e)
            {
                // Wait a variable amount of time in case multiple
                // requests are trying to create the user at once
                var rnd = new Random(DateTime.Now.Millisecond);
                await Task.Delay(rnd.Next(20, 150));
                // Reattempt to retrieve
                userId = await GetUserId(db, userIdClaim, emailClaim);
                if (userId == Guid.Empty)
                {
                    userId = await CreateUser(db, userIdClaim, emailClaim);
                }
            }

            return userId;
        }
    }

    private static async Task<Guid> GetUserId(DataContext db, string? userIdClaim, string? emailClaim)
    {
        Guid userId;

        if (userIdClaim != null)
        {
            if (_users.TryGetValue(userIdClaim, out userId))
            {
                return userId;
            }
        }

        userId = await db.Users
            .Where(x => x.FirebaseId == userIdClaim)
            .Select(x => x.UserId)
            .FirstOrDefaultAsync();

        if (userId == Guid.Empty)
        {
            userId =await db.Users
                .Where(x => x.EmailAddress == emailClaim)
                .Select(x => x.UserId)
                .FirstOrDefaultAsync();
        }

        return userId;
    }

    private static async Task<Guid> CreateUser(DataContext db, string userIdClaim, string? emailClaim)
    {
        var user = new AppUser();
        user.FirebaseId = userIdClaim;
        user.Name = emailClaim;
        user.EmailAddress = emailClaim;
        user.CreatedDate = DateTime.UtcNow;
        db.Add(user);
        await db.SaveChangesAsync();

        // Assign default Roles
        if (emailClaim == "xxx@xxx.io")
        {
            var adminRole = new UserRole<AppUser, Role>();
            adminRole.UserId = user.UserId;
            adminRole.RoleId = SystemRecords.SystemAdministratorRoleId; // Admin role
            db.Add(adminRole);
        }

        await db.SaveChangesAsync();

        _users.TryAdd(userIdClaim, user.UserId);

        return user.UserId;
    }
}
```

## Firebase Configuration

Add your Firebase configuration to appsettings.json:

```json
{
  "FirebaseConfig": {
    "apiKey": "xxxx",
    "authDomain": "xxxx.firebaseapp.com",
    "projectId": "xxxx",
    "storageBucket": "xxxx.appspot.com",
    "messagingSenderId": "xxxx",
    "appId": "1:xxxx:web:xxxx",
    "measurementId": "G-XXXX",
    "providers": ["google", "facebook", "apple", "microsoft"],
    "enableSmsMfa": true
  }
}
```

## OAuth Provider Setup (Google, Facebook, etc.)

**Setup Instructions**: Follow [Google Cloud Console OAuth setup](https://console.cloud.google.com/apis/credentials) to configure each provider.

**Critical for Custom Domains**: Add authorized redirect URIs:

```
https://YOUR_CUSTOM_DOMAIN/__/auth/handler  (Production)
https://localhost:PORT/__/auth/handler      (Development)
```

The `/__/auth/handler` endpoint is automatically provided by Xams (`app.AddFirebaseAuthProxy()`), implementing [Firebase's redirect best practice Option 3](https://firebase.google.com/docs/auth/web/redirect-best-practices) - proxying auth through your backend. This is **required** for custom domains with Google OAuth.

## Test Your Configuration

Navigate to the admin dashboard to verify Firebase authentication is working:

Example: `https://localhost:8000/x`

You should see the Firebase login page with your configured authentication providers.

## React Setup

Install the required npm packages:

```bash
npm install firebase@^11.6.0 @ixeta/xams-firebase @ixeta/headless-auth-react @ixeta/headless-auth-react-firebase
```

Configure your React application environment variables:

```typescript
NEXT_PUBLIC_API=https://localhost:7102/
```

In your `_app.tsx` file, import the Firebase styles and wrap your application with the `XamsFirebaseAuthProvider`. The `auth-recaptcha` div element is required for phone authentication functionality.

```typescript
import '@/styles/globals.css'
import type { AppProps } from 'next/app'
import '@mantine/core/styles.css'
import '@mantine/dates/styles.css'
import { createTheme, MantineProvider } from '@mantine/core'
import {
  AppContextProvider,
  AuthContextProvider,
  getQueryParam,
} from '@ixeta/xams'
import '@ixeta/xams/styles.css'
import '@ixeta/xams/global.css'
import { useRouter } from 'next/router'
import { AuthProvider } from '@ixeta/headless-auth-react'
import { XamsFirebaseAuthProvider } from '@ixeta/xams-firebase'

const theme = createTheme({})

export default function App({ Component, pageProps }: AppProps) {
  const router = useRouter()
  const userId = getQueryParam('userid', router.asPath)

  return (
    <MantineProvider theme={theme}>
      <XamsFirebaseAuthProvider
        apiUrl={process.env.NEXT_PUBLIC_API ?? ''}
        headers={{
          UserId: userId as string,
        }}
        onUnauthorized={(context) => {
          context.firebaseAuthConfig?.signOut()
          if (router.isReady) {
            router.push('/')
          }
        }}
      >
        <AppContextProvider>
          <Component {...pageProps} />
          <div id="auth-recaptcha" className="invisible" />
        </AppContextProvider>
      </XamsFirebaseAuthProvider>
    </MantineProvider>
  )
}
```

Use the authentication pages to set branding and redirect on successful login. Use `postLoginRedirect` in local storage to redirect users to the page they were trying to access before being redirected to login.

```tsx {{ title: 'src/pages/login.tsx' }}
import React from 'react'
import { useRouter } from 'next/router'
import { LoginPage } from '@ixeta/xams-firebase'
import { Logo } from '../components/common/Logo'

const Login = () => {
  const router = useRouter()
  return (
    <LoginPage
      onLoginSuccess={() => {
        const redirectUrl = localStorage.getItem('postLoginRedirect')
        localStorage.removeItem('postLoginRedirect')
        router.push(redirectUrl || '/app/coupons')
      }}
      Logo={<Logo />}
      backgroundColor="#2ea2b0"
      radius={'md'}
    />
  )
}

export default Login
```

Create profile, reset password, and action pages as needed:

```tsx {{ title: 'src/pages/profile.tsx' }}
import React from 'react'
import { ProfilePage } from '@ixeta/xams-firebase'

const Profile = () => {
  return <ProfilePage />
}

export default Profile
```

```tsx {{ title: 'src/pages/reset-password.tsx' }}
import React from 'react'
import { ResetPasswordPage } from '@ixeta/xams-firebase'

const ResetPassword = () => {
  return <ResetPasswordPage />
}

export default ResetPassword
```

```tsx {{ title: 'src/pages/__/auth/action.tsx' }}
import React from 'react'
import { ActionPage } from '@ixeta/xams-firebase'

const AuthAction = () => {
  return <ActionPage />
}

export default AuthAction
```

## React Protected Page

Use the `useAuthProtect` hook to protect pages and access user information:

```tsx {{ title: 'src/pages/admin.tsx' }}
import { AdminDashboard } from '@ixeta/xams'
import React from 'react'
import { NavLink } from '@mantine/core'
import { IconLogout } from '@tabler/icons-react'
import { useRouter } from 'next/router'
import Loading from '@/components/common/Loading'
import { useAuthProtect } from '@ixeta/xams-firebase'

const Admin = () => {
  const router = useRouter()
  const auth = useAuthProtect()

  if (auth.isLoading || !router.isReady) {
    return <Loading />
  }

  if (auth.isError) {
    return <div>Error loading auth settings</div>
  }

  if (!auth.isLoggedIn) {
    localStorage.setItem('postLoginRedirect', router.asPath)
    router.push('/login')
    return <></>
  }

  return (
    <AdminDashboard
      addMenuItems={[
        {
          order: 10000,
          navLink: (
            <NavLink
              label="Logout"
              leftSection={<IconLogout size={16} />}
              onClick={() => {
                auth.signOut()
                router.push('/')
              }}
            />
          ),
        },
      ]}
    />
  )
}

export default Admin
```

## Using Tanstack Query with Authentication

When using Tanstack Query with authenticated pages, **always** set `enabled: auth.isLoggedIn` to prevent queries from running before authentication is ready. All hooks must be called at the top level before any conditional returns.

```tsx {{ title: 'src/pages/dashboard.tsx' }}
import { Query, useAuthRequest } from '@ixeta/xams'
import { useAuthProtect } from '@ixeta/xams-firebase'
import { useQuery } from '@tanstack/react-query'
import { useRouter } from 'next/router'

const Dashboard = () => {
  const router = useRouter()
  const auth = useAuthProtect()
  const authRequest = useAuthRequest()

  // Call ALL hooks at the top level
  const { data, isLoading } = useQuery({
    queryKey: ['my-data'],
    queryFn: async () => {
      const readRequest = new Query(['*'])
        .from('MyTable')
        .top(10)
        .toReadRequest()
      const response = await authRequest.read(readRequest)
      if (!response.succeeded) throw new Error(response.friendlyMessage)
      return response.data.results
    },
    enabled: auth.isLoggedIn, // CRITICAL: Prevents query until authenticated
  })

  // Auth checks come AFTER all hooks
  if (auth.isLoading || !router.isReady) {
    return <div>Loading...</div>
  }

  if (!auth.isLoggedIn) {
    localStorage.setItem('postLoginRedirect', router.asPath)
    router.push('/login')
    return <></>
  }

  return <div>{/* Use data here */}</div>
}
```

## Firebase Email Templates

Configure the Firebase email template action URL to redirect to your Xams application:

1. Navigate to **Authentication â†’ Templates** in the Firebase console
2. Select an email template and click **Edit Template**
3. Click **Customize action URL**
4. Set the URL to your application's action handler (e.g., `https://localhost:3000/__/auth/action`)

This URL handles email verification, password reset, and other Firebase authentication actions.
